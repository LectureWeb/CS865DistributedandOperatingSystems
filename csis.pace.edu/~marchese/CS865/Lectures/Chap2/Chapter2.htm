<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 9">
<meta name=Originator content="Microsoft Word 9">
<link rel=File-List href="./Chapter2_files/filelist.xml">
<link rel=Edit-Time-Data href="./Chapter2_files/editdata.mso">
<!--[if !mso]>
<style>
v\:* {behavior:url(#default#VML);}
o\:* {behavior:url(#default#VML);}
w\:* {behavior:url(#default#VML);}
.shape {behavior:url(#default#VML);}
</style>
<![endif]-->
<title>Chapter 2</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Francis Marchese</o:Author>
  <o:LastAuthor>Francis Marchese</o:LastAuthor>
  <o:Revision>17</o:Revision>
  <o:TotalTime>36</o:TotalTime>
  <o:Created>2006-12-22T16:33:00Z</o:Created>
  <o:LastSaved>2006-12-22T19:54:00Z</o:LastSaved>
  <o:Pages>20</o:Pages>
  <o:Words>11852</o:Words>
  <o:Characters>67558</o:Characters>
  <o:Company>Pace University</o:Company>
  <o:Lines>562</o:Lines>
  <o:Paragraphs>135</o:Paragraphs>
  <o:CharactersWithSpaces>82965</o:CharactersWithSpaces>
  <o:Version>9.2720</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:Zoom>BestFit</w:Zoom>
  <w:DrawingGridHorizontalSpacing>6 pt</w:DrawingGridHorizontalSpacing>
  <w:DisplayHorizontalDrawingGridEvery>2</w:DisplayHorizontalDrawingGridEvery>
  <w:DisplayVerticalDrawingGridEvery>2</w:DisplayVerticalDrawingGridEvery>
 </w:WordDocument>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
@font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;
	mso-font-charset:2;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:0 268435456 0 0 -2147483648 0;}
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
h3
	{mso-style-next:Normal;
	margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:3;
	font-size:13.0pt;
	font-family:Arial;}
@page Section1
	{size:8.5in 11.0in;
	margin:73.45pt 49.6pt 73.45pt 49.6pt;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
 /* List Definitions */
@list l0
	{mso-list-id:421488667;
	mso-list-type:hybrid;
	mso-list-template-ids:1680627652 67698703 67698713 67698715 67698703 67698713 67698715 67698703 67698713 67698715;}
@list l1
	{mso-list-id:447897358;
	mso-list-type:hybrid;
	mso-list-template-ids:-577107090 67698689 67698691 67698693 67698689 67698691 67698693 67698689 67698691 67698693;}
@list l1:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	font-family:Symbol;}
@list l2
	{mso-list-id:491483499;
	mso-list-type:hybrid;
	mso-list-template-ids:-674084848 67698703 67698713 67698715 67698703 67698713 67698715 67698703 67698713 67698715;}
@list l3
	{mso-list-id:1065375949;
	mso-list-type:hybrid;
	mso-list-template-ids:68321268 67698703 67698713 67698715 67698703 67698713 67698715 67698703 67698713 67698715;}
@list l4
	{mso-list-id:1708290190;
	mso-list-type:hybrid;
	mso-list-template-ids:-577107090 67698703 67698691 67698693 67698689 67698691 67698693 67698689 67698691 67698693;}
ol
	{margin-bottom:0in;}
ul
	{margin-bottom:0in;}
-->
</style>
<!--[if gte mso 9]><xml>
 <o:shapedefaults v:ext="edit" spidmax="1062">
  <o:colormru v:ext="edit" colors="#eaeaea,#f8f8f8"/>
  <o:colormenu v:ext="edit" fillcolor="#f8f8f8"/>
 </o:shapedefaults></xml><![endif]--><!--[if gte mso 9]><xml>
 <o:shapelayout v:ext="edit">
  <o:idmap v:ext="edit" data="1"/>
 </o:shapelayout></xml><![endif]-->
</head>

<body bgcolor="#f8f8f8" lang=EN-US style='tab-interval:.5in'>

<div class=Section1>

<h3>Chapter 2. Architectures</h3>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Distributed systems are
often complex pieces of software of which the components are by definition
dispersed across multiple machines. To master their complexity, it is crucial that
these systems are properly organized. There are different ways on how to view
the organization of a distributed system, but an obvious one is to make a
distinction between the logical organization of the collection of software
components and on the other hand the actual physical realization.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>The organization of
distributed systems is mostly about the software components that constitute the
system. These software architectures tell us how the various software
components are to be organized and how they should interact. In this chapter we
will first pay attention to some commonly applied approaches toward organizing
(distributed) computer systems.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>The actual realization of a
distributed system requires that we instantiate and place software components on
real machines. There are many different choices that can be made in doing so.
The final instantiation of a software architecture is also referred to as a
system architecture. In this chapter we will look into traditional centralized
architectures in which a single server implements most of the software
components (and thus functionality), while remote clients can access that
server using simple communication means. In addition, we consider decentralized
architectures in which machines more or less play equal roles, as well as
hybrid organizations.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>As we explained in Chap. 1,
an important goal of distributed systems is to separate applications from
underlying platforms by providing a middleware layer. Adopting such a layer is
an important architectural decision, and its main purpose is to provide
distribution transparency. However, trade-offs need to be made to achieve
transparency, which has led to various techniques to make middleware adaptive.
We discuss some of the more commonly applied ones in this chapter, as they
affect the organization of the middleware itself.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>[Page 34]<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Adaptability in distributed
systems can also be achieved by having the system monitor its own behavior and
taking appropriate measures when needed. This insight has led to a class of
what are now referred to as autonomic systems. These distributed systems are
frequently organized in the form of feedback control loops, which form an
important architectural element during a system's design. In this chapter, we
devote a section to autonomic distributed systems.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<h3>2.1. Architectural Styles</h3>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>We start our discussion on
architectures by first considering the logical organization of distributed
systems into software components, also referred to as software architecture
(Bass et al., 2003). Research on software architectures has matured
considerably and it is now commonly accepted that designing or adopting an
architecture is crucial for the successful development of large systems.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>For our discussion, the
notion of an architectural style is important. Such a style is formulated in
terms of components, the way that components are connected to each other, the
data exchanged between components, and finally how these elements are jointly
configured into a system. A component is a modular unit with well-defined
required and provided interfaces that is replaceable within its environment
(OMG, 2004b). As we shall discuss below, the important issue about a component
for distributed systems is that it can be replaced, provided we respect its
interfaces. A somewhat more difficult concept to grasp is that of a connector,
which is generally described as a mechanism that mediates communication,
coordination, or cooperation among components (Mehta et al., 2000; and Shaw and
Clements, 1997). For example, a connector can be formed by the facilities for
(remote) procedure calls, message passing, or streaming data.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Using components and
connectors, we can come to various configurations, which, in turn have been
classified into architectural styles. Several styles have by now been
identified, of which the most important ones for distributed systems are:<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal style='mso-list:l0 level1 lfo3;tab-stops:list .5in'><span
     style='font-family:Arial'>Layered architectures<o:p></o:p></span></li>
</ol>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<ol style='margin-top:0in' start=2 type=1>
 <li class=MsoNormal style='mso-list:l0 level1 lfo3;tab-stops:list .5in'><span
     style='font-family:Arial'>Object-based architectures<o:p></o:p></span></li>
</ol>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<ol style='margin-top:0in' start=3 type=1>
 <li class=MsoNormal style='mso-list:l0 level1 lfo3;tab-stops:list .5in'><span
     style='font-family:Arial'>Data-centered architectures<o:p></o:p></span></li>
</ol>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<ol style='margin-top:0in' start=4 type=1>
 <li class=MsoNormal style='mso-list:l0 level1 lfo3;tab-stops:list .5in'><span
     style='font-family:Arial'>Event-based architectures<o:p></o:p></span></li>
</ol>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>The basic idea for the layered
style is simple: components are organized in a layered fashion where a
component at layer Li is allowed to call components at the underlying layer
Li-1, but not the other way around, as shown in Fig. 2-1(a). This model has
been widely adopted by the networking community; we briefly review it in Chap.
4. An key observation is that control generally flows from layer to layer:
requests go down the hierarchy whereas the results flow upward.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>[Page 35]<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Figure 2-1. The (a) layered
and (b) object-based architectural style.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><!--[if gte vml 1]><v:shapetype
 id="_x0000_t75" coordsize="21600,21600" o:spt="75" o:preferrelative="t"
 path="m@4@5l@4@11@9@11@9@5xe" filled="f" stroked="f">
 <v:stroke joinstyle="miter"/>
 <v:formulas>
  <v:f eqn="if lineDrawn pixelLineWidth 0"/>
  <v:f eqn="sum @0 1 0"/>
  <v:f eqn="sum 0 0 @1"/>
  <v:f eqn="prod @2 1 2"/>
  <v:f eqn="prod @3 21600 pixelWidth"/>
  <v:f eqn="prod @3 21600 pixelHeight"/>
  <v:f eqn="sum @0 0 1"/>
  <v:f eqn="prod @6 1 2"/>
  <v:f eqn="prod @7 21600 pixelWidth"/>
  <v:f eqn="sum @8 21600 0"/>
  <v:f eqn="prod @7 21600 pixelHeight"/>
  <v:f eqn="sum @10 21600 0"/>
 </v:formulas>
 <v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"/>
 <o:lock v:ext="edit" aspectratio="t"/>
</v:shapetype><v:shape id="_x0000_i1025" type="#_x0000_t75" style='width:245.25pt;
 height:214.5pt'>
 <v:imagedata src="./Chapter2_files/image001.jpg" o:title="fg2-1a"/>
</v:shape><![endif]--><![if !vml]><img width=327 height=286
src="./Chapter2_files/image002.jpg" v:shapes="_x0000_i1025"><![endif]><span
style='mso-tab-count:1'>  </span><!--[if gte vml 1]><v:shape id="_x0000_i1026"
 type="#_x0000_t75" style='width:238.5pt;height:209.25pt'>
 <v:imagedata src="./Chapter2_files/image003.jpg" o:title="fg2-1b"/>
</v:shape><![endif]--><![if !vml]><img width=318 height=279
src="./Chapter2_files/image004.jpg" v:shapes="_x0000_i1026"><![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>A far looser organization is
followed in object-based architectures, which are illustrated in Fig. 2-1(b).
In essence, each object corresponds to what we have defined as a component, and
these components are connected through a (remote) procedure call mechanism. Not
surprisingly, this software architecture matches the client-server system
architecture we described above. The layered and object-based architectures
still form the most important styles for large software systems (Bass et al.,
2003).<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Data-centered architectures
evolve around the idea that processes communicate through a common (passive or
active) repository. It can be argued that for distributed systems these
architectures are as important as the layered and object-based architectures.
For example, a wealth of networked applications have been developed that rely
on a shared distributed file system in which virtually all communication takes
place through files. Likewise, Web-based distributed systems, which we discuss extensively
in Chap. 12, are largely data-centric: processes communicate through the use of
shared Web-based data services.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>In event-based
architectures, processes essentially communicate through the propagation of
events, which optionally also carry data, as shown in Fig. 2-2(a). For
distributed systems, event propagation has generally been associated with what
are known as publish/subscribe systems (Eugster et al., 2003). The basic idea
is that processes publish events after which the middleware ensures that only
those processes that subscribed to those events will receive them. The main
advantage of event-based systems is that processes are loosely coupled. In
principle, they need not explicitly refer to each other. This is also referred
to as being decoupled in space, or referentially decoupled.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>[Page 36]<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Figure 2-2. The (a)
event-based and (b) shared data-space architectural style.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><!--[if gte vml 1]><v:shape
 id="_x0000_i1027" type="#_x0000_t75" style='width:276.75pt;height:175.5pt'>
 <v:imagedata src="./Chapter2_files/image005.jpg" o:title="fg2-2a"/>
</v:shape><![endif]--><![if !vml]><img width=369 height=234
src="./Chapter2_files/image006.jpg" v:shapes="_x0000_i1027"><![endif]><span
style='mso-tab-count:1'>            </span><!--[if gte vml 1]><v:shape id="_x0000_i1028"
 type="#_x0000_t75" style='width:287.25pt;height:179.25pt'>
 <v:imagedata src="./Chapter2_files/image007.jpg" o:title="fg2-2b"/>
</v:shape><![endif]--><![if !vml]><img width=383 height=239
src="./Chapter2_files/image008.jpg" v:shapes="_x0000_i1028"><![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Event-based architectures
can be combined with data-centered architectures, yielding what is also known as
shared data spaces. The essence of shared data spaces is that processes are now
also decoupled in time: they need not both be active when communication takes
place. Furthermore, many shared data spaces use a SQL-like interface to the
shared repository in that sense that data can be accessed using a description
rather than an explicit reference, as is the case with files. We devote Chap.
13 to this architectural style.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>What makes these software
architectures important for distributed systems is that they all aim at
achieving (at a reasonable level) distribution transparency. However, as we
have argued, distribution transparency requires making trade-offs between
performance, fault tolerance, ease-of-programming, and so on. As there is no
single solution that will meet the requirements for all possible distributed
applications, researchers have abandoned the idea that a single distributed
system can be used to cover 90% of all possible cases.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<h3>2.2. System Architectures</h3>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Now that we have briefly
discussed some common architectural styles, let us take a look at how many
distributed systems are actually organized by considering where software
components are placed. Deciding on software components, their interaction, and
their placement leads to an instance of a software architecture, also called a
system architecture (Bass et al., 2003). We will discuss centralized and
decentralized organizations, as well as various hybrid forms.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<h3>2.2.1. Centralized Architectures</h3>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Despite the lack of
consensus on many distributed systems issues, there is one issue that many
researchers and practitioners agree upon: thinking in terms of clients that
request services from servers helps us understand and manage the complexity of
distributed systems and that is a good thing.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>[Page 37]<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>In the basic client-server
model, processes in a distributed system are divided into two (possibly
overlapping) groups. A server is a process implementing a specific service, for
example, a file system service or a database service. A client is a process
that requests a service from a server by sending it a request and subsequently
waiting for the server's reply. This client-server interaction, also known as
request-reply behavior is shown in Fig. 2-3<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Figure 2-3. General
interaction between a client and a server.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><!--[if gte vml 1]><v:shape
 id="_x0000_i1029" type="#_x0000_t75" style='width:366.75pt;height:139.5pt'>
 <v:imagedata src="./Chapter2_files/image009.jpg" o:title="fg2-3"/>
</v:shape><![endif]--><![if !vml]><img width=489 height=186
src="./Chapter2_files/image010.jpg" v:shapes="_x0000_i1029"><![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Communication between a
client and a server can be implemented by means of a simple connectionless
protocol when the underlying network is fairly reliable as in many local-area
networks. In these cases, when a client requests a service, it simply packages
a message for the server, identifying the service it wants, along with the
necessary input data. The message is then sent to the server. The latter, in
turn, will always wait for an incoming request, subsequently process it, and
package the results in a reply message that is then sent to the client.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Using a connectionless
protocol has the obvious advantage of being efficient. As long as messages do
not get lost or corrupted, the request/reply protocol just sketched works fine.
Unfortunately, making the protocol resistant to occasional transmission
failures is not trivial. The only thing we can do is possibly let the client
resend the request when no reply message comes in. The problem, however, is
that the client cannot detect whether the original request message was lost, or
that transmission of the reply failed. If the reply was lost, then resending a
request may result in performing the operation twice. If the operation was
something like &quot;transfer $10,000 from my bank account,&quot; then clearly,
it would have been better that we simply reported an error instead. On the
other hand, if the operation was &quot;tell me how much money I have
left,&quot; it would be perfectly acceptable to resend the request. When an
operation can be repeated multiple times without harm, it is said to be
idempotent. Since some requests are idempotent and others are not it should be
clear that there is no single solution for dealing with lost messages. We defer
a detailed discussion on handling transmission failures to Chap. 8.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>As an alternative, many
client-server systems use a reliable connection-oriented protocol. Although
this solution is not entirely appropriate in a local-area network due to
relatively low performance, it works perfectly fine in wide-area systems in
which communication is inherently unreliable. For example, virtually all
Internet application protocols are based on reliable TCP/IP connections. In
this case, whenever a client requests a service, it first sets up a connection
to the server before sending the request. The server generally uses that same
connection to send the reply message, after which the connection is torn down.
The trouble is that setting up and tearing down a connection is relatively
costly, especially when the request and reply messages are small.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>[Page 38]<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<h3>Application Layering</h3>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>The client-server model has
been subject to many debates and controversies over the years. One of the main
issues was how to draw a clear distinction between a client and a server. Not surprisingly,
there is often no clear distinction. For example, a server for a distributed
database may continuously act as a client because it is forwarding requests to
different file servers responsible for implementing the database tables. In
such a case, the database server itself essentially does no more than process
queries.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>However, considering that
many client-server applications are targeted toward supporting user access to
databases, many people have advocated a distinction between the following three
levels, essentially following the layered architectural style we discussed
previously:<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal style='mso-list:l3 level1 lfo9;tab-stops:list .5in'><span
     style='font-family:Arial'>The user-interface level<o:p></o:p></span></li>
</ol>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<ol style='margin-top:0in' start=2 type=1>
 <li class=MsoNormal style='mso-list:l3 level1 lfo9;tab-stops:list .5in'><span
     style='font-family:Arial'>The processing level<o:p></o:p></span></li>
</ol>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<ol style='margin-top:0in' start=3 type=1>
 <li class=MsoNormal style='mso-list:l3 level1 lfo9;tab-stops:list .5in'><span
     style='font-family:Arial'>The data level<o:p></o:p></span></li>
</ol>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>The user-interface level
contains all that is necessary to directly interface with the user, such as
display management. The processing level typically contains the applications.
The data level manages the actual data that is being acted on.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Clients typically implement
the user-interface level. This level consists of the programs that allow end
users to interact with applications. There is a considerable difference in how
sophisticated user-interface programs are.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>The simplest user-interface
program is nothing more than a character-based screen. Such an interface has
been typically used in mainframe environments. In those cases where the
mainframe controls all interaction, including the keyboard and monitor, one can
hardly speak of a client-server environment. However, in many cases, the user's
terminal does some local processing such as echoing typed keystrokes, or
supporting form-like interfaces in which a complete entry is to be edited
before sending it to the main computer.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Nowadays, even in mainframe
environments, we see more advanced user interfaces. Typically, the client
machine offers at least a graphical display in which pop-up or pull-down menus
are used, and of which many of the screen controls are handled through a mouse
instead of the keyboard. Typical examples of such interfaces include the
X-Windows interfaces as used in many UNIX environments, and earlier interfaces
developed for MS-DOS PCs and Apple Macintoshes.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>[Page 39]<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Modern user interfaces offer
considerably more functionality by allowing applications to share a single
graphical window, and to use that window to exchange data through user actions.
For example, to delete a file, it is usually possible to move the icon
representing that file to an icon representing a trash can. Likewise, many word
processors allow a user to move text in a document to another position by using
only the mouse. We return to user interfaces in Chap. 3.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Many client-server
applications can be constructed from roughly three different pieces: a part
that handles interaction with a user, a part that operates on a database or
file system, and a middle part that generally contains the core functionality
of an application. This middle part is logically placed at the processing
level. In contrast to user interfaces and databases, there are not many aspects
common to the processing level. Therefore, we shall give several examples to
make this level clearer.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>As a first example, consider
an Internet search engine. Ignoring all the animated banners, images, and other
fancy window dressing, the user interface of a search engine is very simple: a
user types in a string of keywords and is subsequently presented with a list of
titles of Web pages. The back end is formed by a huge database of Web pages
that have been prefetched and indexed. The core of the search engine is a
program that transforms the user's string of keywords into one or more database
queries. It subsequently ranks the results into a list, and transforms that
list into a series of HTML pages. Within the client-server model, this
information retrieval part is typically placed at the processing level. Fig. 2-4
shows this organization.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Figure 2-4. The simplified
organization of an Internet search engine into three different layers.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><!--[if gte vml 1]><v:shape
 id="_x0000_i1030" type="#_x0000_t75" style='width:512.25pt;height:278.25pt'>
 <v:imagedata src="./Chapter2_files/image011.jpg" o:title="fg2-4"/>
</v:shape><![endif]--><![if !vml]><img width=683 height=371
src="./Chapter2_files/image012.jpg" v:shapes="_x0000_i1030"><![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>As a second example,
consider a decision support system for a stock brokerage. Analogous to a search
engine, such a system can be divided into a front end implementing the user
interface, a back end for accessing a database with the financial data, and the
analysis programs between these two. Analysis of financial data may require
sophisticated methods and techniques from statistics and artificial
intelligence. In some cases, the core of a financial decision support system
may even need to be executed on high-performance computers in order to achieve
the throughput and responsiveness that is expected from its users.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>[Page 40]<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>As a last example, consider
a typical desktop package, consisting of a word processor, a spreadsheet
application, communication facilities, and so on. Such &quot;office&quot;
suites are generally integrated through a common user interface that supports
compound documents, and operates on files from the user's home directory. (In
an office environment, this home directory is often placed on a remote file
server.) In this example, the processing level consists of a relatively large
collection of programs, each having rather simple processing capabilities.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>The data level in the
client-server model contains the programs that maintain the actual data on
which the applications operate. An important property of this level is that
data are often persistent, that is, even if no application is running, data
will be stored somewhere for next use. In its simplest form, the data level
consists of a file system, but it is more common to use a full-fledged
database. In the client-server model, the data level is typically implemented
at the server side.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Besides merely storing data,
the data level is generally also responsible for keeping data consistent across
different applications. When databases are being used, maintaining consistency
means that metadata such as table descriptions, entry constraints and
application-specific metadata are also stored at this level. For example, in
the case of a bank, we may want to generate a notification when a customer's
credit card debt reaches a certain value. This type of information can be
maintained through a database trigger that activates a handler for that trigger
at the appropriate moment.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>In most business-oriented
environments, the data level is organized as a relational database. Data
independence is crucial here. The data are organized independent of the
applications in such a way that changes in that organization do not affect
applications, and neither do the applications affect the data organization.
Using relational databases in the client-server model helps separate the
processing level from the data level, as processing and data are considered
independent.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>However, relational
databases are not always the ideal choice. A characteristic feature of many
applications is that they operate on complex data types that are more easily
modeled in terms of objects than in terms of relations. Examples of such data
types range from simple polygons and circles to representations of aircraft
designs, as is the case with computer-aided design (CAD) systems.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>In those cases where data operations
are more easily expressed in terms of object manipulations, it makes sense to
implement the data level by means of an object-oriented or object-relational
database. Notably the latter type has gained popularity as these databases
build upon the widely dispersed relational data model, while offering the
advantages that object-orientation gives.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>[Page 41]<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<h3>Multitiered Architectures</h3>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>The distinction into three
logical levels as discussed so far, suggests a number of possibilities for
physically distributing a client-server application across several machines.
The simplest organization is to have only two types of machines:<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>A client machine containing
only the programs implementing (part of) the user-interface level<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>A server machine containing
the rest, that is the programs implementing the processing and data level<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>In this organization
everything is handled by the server while the client is essentially no more
than a dumb terminal, possibly with a pretty graphical interface. There are many
other possibilities, of which we explore some of the more common ones in this
section.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>One approach for organizing
the clients and servers is to distribute the programs in the application layers
of the previous section across different machines, as shown in Fig. 2-5 [see
also Umar (1997); and Jing et al. (1999)]. As a first step, we make a
distinction between only two kinds of machines: client machines and server
machines, leading to what is also referred to as a (physically) two-tiered
architecture.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Figure 2-5. Alternative
client-server organizations (a)–(e).<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><!--[if gte vml 1]><v:shape
 id="_x0000_i1031" type="#_x0000_t75" style='width:513pt;height:222.75pt'>
 <v:imagedata src="./Chapter2_files/image013.jpg" o:title="fg2-5"/>
</v:shape><![endif]--><![if !vml]><img width=684 height=297
src="./Chapter2_files/image014.jpg" v:shapes="_x0000_i1031"><![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>One possible organization is
to have only the terminal-dependent part of the user interface on the client
machine, as shown in Fig. 2-5(a), and give the applications remote control over
the presentation of their data. An alternative is to place the entire
user-interface software on the client side, as shown in Fig. 2-5(b). In such
cases, we essentially divide the application into a graphical front end, which
communicates with the rest of the application (residing at the server) through
an application-specific protocol. In this model, the front end (the client
software) does no processing other than necessary for presenting the
application's interface.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>[Page 42]<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Continuing along this line of
reasoning, we may also move part of the application to the front end, as shown
in Fig. 2-5(c). An example where this makes sense is where the application
makes use of a form that needs to be filled in entirely before it can be
processed. The front end can then check the correctness and consistency of the
form, and where necessary interact with the user. Another example of the
organization of Fig. 2-5(c), is that of a word processor in which the basic
editing functions execute on the client side where they operate on locally
cached, or in-memory data, but where the advanced support tools such as
checking the spelling and grammar execute on the server side.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>In many client-server
environments, the organizations shown in Fig. 2-5(d) and Fig. 2-5(e) are particularly
popular. These organizations are used where the client machine is a PC or
workstation, connected through a network to a distributed file system or
database. Essentially, most of the application is running on the client
machine, but all operations on files or database entries go to the server. For
example, many banking applications run on an end-user's machine where the user
prepares transactions and such. Once finished, the application contacts the
database on the bank's server and uploads the transactions for further
processing. Fig. 2-5(e) represents the situation where the client's local disk
contains part of the data. For example, when browsing the Web, a client can
gradually build a huge cache on local disk of most recent inspected Web pages.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>We note that for a few years
there has been a strong trend to move away from the configurations shown in
Fig. 2-5(d) and Fig. 2-5(e) in those case that client software is placed at
end-user machines. In these cases, most of the processing and data storage is
handled at the server side. The reason for this is simple: although client
machines do a lot, they are also more problematic to manage. Having more
functionality on the client machine makes client-side software more prone to
errors and more dependent on the client's underlying platform (i.e., operating
system and resources). From a system's management perspective, having what are
called fat clients is not optimal. Instead the thin clients as represented by
the organizations shown in Fig. 2-5(a)–(c) are much easier, perhaps at the cost
of less sophisticated user interfaces and client-perceived performance.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Note that this trend does
not imply that we no longer need distributed systems. On the contrary, what we
are seeing is that server-side solutions are becoming increasingly more
distributed as a single server is being replaced by multiple servers running on
different machines. In particular, when distinguishing only client and server
machines as we have done so far, we miss the point that a server may sometimes
need to act as a client, as shown in Fig. 2-6, leading to a (physically)
three-tiered architecture.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Figure 2-6. An example of a
server acting as client. <o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>(This item is displayed on
page 43 in the print version) <o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><!--[if gte vml 1]><v:shape
 id="_x0000_i1032" type="#_x0000_t75" style='width:512.25pt;height:3in'>
 <v:imagedata src="./Chapter2_files/image015.jpg" o:title="fg2-6"/>
</v:shape><![endif]--><![if !vml]><img width=683 height=288
src="./Chapter2_files/image016.jpg" v:shapes="_x0000_i1032"><![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>In this architecture, programs
that form part of the processing level reside on a separate server, but may
additionally be partly distributed across the client and server machines. A
typical example of where a three-tiered architecture is used is in transaction
processing. As we discussed in Chap. 1, a separate process, called the
transaction processing monitor, coordinates all transactions across possibly
different data servers.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>[Page 43]<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Another, but very different
example where we often see a three-tiered architecture is in the organization
of Web sites. In this case, a Web server acts as an entry point to a site,
passing requests to an application server where the actual processing takes
place. This application server, in turn, interacts with a database server. For
example, an application server may be responsible for running the code to
inspect the available inventory of some goods as offered by an electronic
bookstore. To do so, it may need to interact with a database containing the raw
inventory data. We will come back to Web site organization in Chap. 12.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<h3>2.2.2. Decentralized Architectures</h3>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Multitiered client-server
architectures are a direct consequence of dividing applications into a
user-interface, processing components, and a data level. The different tiers
correspond directly with the logical organization of applications. In many
business environments, distributed processing is equivalent to organizing a
client-server application as a multitiered architecture. We refer to this type
of distribution as vertical distribution. The characteristic feature of
vertical distribution is that it is achieved by placing logically different
components on different machines. The term is related to the concept of
vertical fragmentation as used in distributed relational databases, where it
means that tables are split column-wise, and subsequently distributed across
multiple machines (Oszu and Valduriez, 1999).<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Again, from a system
management perspective, having a vertical distribution can help: functions are
logically and physically split across multiple machines, where each machine is
tailored to a specific group of functions. However, vertical distribution is
only one way of organizing client-server applications. In modern architectures,
it is often the distribution of the clients and the servers that counts, which
we refer to as horizontal distribution. In this type of distribution, a client
or server may be physically split up into logically equivalent parts, but each
part is operating on its own share of the complete data set, thus balancing the
load. In this section we will take a look at a class of modern system
architectures that support horizontal distribution, known as peer-to-peer
systems.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>[Page 44]<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>From a high-level
perspective, the processes that constitute a peer-to-peer system are all equal.
This means that the functions that need to be carried out are represented by
every process that constitutes the distributed system. As a consequence, much
of the interaction between processes is symmetric: each process will act as a client
and a server at the same time (which is also referred to as acting as a
servent).<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Given this symmetric
behavior, peer-to-peer architectures evolve around the question how to organize
the processes in an overlay network, that is, a network in which the nodes are
formed by the processes and the links represent the possible communication
channels (which are usually realized as TCP connections). In general, a process
cannot communicate directly with an arbitrary other process, but is required to
send messages through the available communication channels. Two types of
overlay networks exist: those that are structured and those that are not. These
two types are surveyed extensively in Lua et al. (2005) along with numerous
examples. Aberer et al. (2005) provide a reference architecture that allows for
a more formal comparison of the different types of peer-to-peer systems. A
survey taken from the perspective of content distribution is provided by
Androutsellis-Theotokis and Spinellis (2004).<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<h3>Structured Peer-to-Peer Architectures</h3>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>In a structured peer-to-peer
architecture, the overlay network is constructed using a deterministic
procedure. By far the most-used procedure is to organize the processes through
a distributed hash table (DHT). In a DHT-based system, data items are assigned
a random key from a large identifier space, such as a 128-bit or 160-bit
identifier. Likewise, nodes in the system are also assigned a random number
from the same identifier space. The crux of every DHT-based system is then to
implement an efficient and deterministic scheme that uniquely maps the key of a
data item to the identifier of a node based on some distance metric
(Balakrishnan, 2003). Most importantly, when looking up a data item, the
network address of the node responsible for that data item is returned.
Effectively, this is accomplished by routing a request for a data item to the
responsible node.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>For example, in the Chord
system (Stoica et al., 2003) the nodes are logically organized in a ring such
that a data item with key k is mapped to the node with the smallest identifier
idk. This node is referred to as the successor of key k and denoted as succ(k),
as shown in Fig. 2-7. To actually look up the data item, an application running
on an arbitrary node would then call the function LOOKUP(k) which would
subsequently return the network address of succ(k). At that point, the
application can contact the node to obtain a copy of the data item.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>[Page 45]<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Figure 2-7. The mapping of
data items onto nodes in Chord.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><!--[if gte vml 1]><v:shape
 id="_x0000_i1033" type="#_x0000_t75" style='width:269.25pt;height:267pt'>
 <v:imagedata src="./Chapter2_files/image017.jpg" o:title="fg2-7"/>
</v:shape><![endif]--><![if !vml]><img width=359 height=356
src="./Chapter2_files/image018.jpg" v:shapes="_x0000_i1033"><![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>We will not go into
algorithms for looking up a key now, but defer that discussion until Chap. 5
where we describe details of various naming systems. Instead, let us
concentrate on how nodes organize themselves into an overlay network, or, in
other words, membership management. In the following, it is important to
realize that looking up a key does not follow the logical organization of nodes
in the ring from Fig. 2-7. Rather, each node will maintain shortcuts to other
nodes in such a way that lookups can generally be done in &#927;(log (N))
number of steps, where N is the number of nodes participating in the overlay.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Now consider Chord again.
When a node wants to join the system, it starts with generating a random identifier
id. Note that if the identifier space is large enough, then provided the random
number generator is of good quality, the probability of generating an
identifier that is already assigned to an actual node is close to zero. Then,
the node can simply do a lookup on id, which will return the network address of
succ(id). At that point, the joining node can simply contact succ(id) and its
predecessor and insert itself in the ring. Of course, this scheme requires that
each node also stores information on its predecessor. Insertion also yields
that each data item whose key is now associated with node id, is transferred
from succ(id).<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Leaving is just as simple:
node id informs its departure to its predecessor and successor, and transfers
its data items to succ(id).<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Similar approaches are
followed in other DHT-based systems. As an example, consider the Content
Addressable Network (CAN), described in Ratnasamy et al. (2001). CAN deploys a
d-dimensional Cartesian coordinate space, which is completely partitioned among
all all the nodes that participate in the system. For purpose of illustration,
let us consider only the 2-dimensional case, of which an example is shown in
Fig. 2-8.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>[Page 46]<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Figure 2-8. (a) The mapping
of data items onto nodes in CAN. (b) Splitting a region when a node joins.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><!--[if gte vml 1]><v:shape
 id="_x0000_i1034" type="#_x0000_t75" style='width:222.75pt;height:255.75pt'>
 <v:imagedata src="./Chapter2_files/image019.jpg" o:title="fg2-8a"/>
</v:shape><![endif]--><![if !vml]><img width=297 height=341
src="./Chapter2_files/image020.jpg" v:shapes="_x0000_i1034"><![endif]><span
style='mso-tab-count:1'>          </span><!--[if gte vml 1]><v:shape id="_x0000_i1035"
 type="#_x0000_t75" style='width:235.5pt;height:254.25pt'>
 <v:imagedata src="./Chapter2_files/image021.jpg" o:title="fg2-8b"/>
</v:shape><![endif]--><![if !vml]><img width=314 height=339
src="./Chapter2_files/image022.jpg" v:shapes="_x0000_i1035"><![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Fig. 2-8(a) shows how the
two-dimensional space [0,1]x[0,1] is divided among six nodes. Each node has an
associated region. Every data item in CAN will be assigned a unique point in
this space, after which it is also clear which node is responsible for that
data (ignoring data items that fall on the border of multiple regions, for
which a deterministic assignment rule is used).<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>When a node P wants to join
a CAN system, it picks an arbitrary point from the coordinate space and
subsequently looks up the node Q in whose region that point falls. This lookup
is accomplished through positioned-based routing, of which the details are
deferred until later chapters. Node Q then splits its region into two halves,
as shown in Fig. 2-8(b), and one half is assigned to the node P. Nodes keep
track of their neighbors, that is, nodes responsible for adjacent region. When
splitting a region, the joining node P can easily come to know who its new
neighbors are by asking node P. As in Chord, the data items for which node P is
now responsible are transferred from node Q.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Leaving is a bit more
problematic in CAN. Assume that in Fig. 2-8, the node with coordinate (0.6,0.7)
leaves. Its region will be assigned to one of its neighbors, say the node at
(0.9,0.9), but it is clear that simply merging it and obtaining a rectangle
cannot be done. In this case, the node at (0.9,0.9) will simply take care of
that region and inform the old neighbors of this fact. Obviously, this may lead
to less symmetric partitioning of the coordinate space, for which reason a
background process is periodically started to repartition the entire space.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>[Page 47]<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<h3>Unstructured Peer-to-Peer Architectures</h3>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Unstructured peer-to-peer
systems largely rely on randomized algorithms for constructing an overlay
network. The main idea is that each node maintains a list of neighbors, but
that this list is constructed in a more or less random way. Likewise, data
items are assumed to be randomly placed on nodes. As a consequence, when a node
needs to locate a specific data item, the only thing it can effectively do is
flood the network with a search query (Risson and Moors, 2006). We will return
to searching in unstructured overlay networks in Chap. 5, and for now
concentrate on membership management.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>One of the goals of many
unstructured peer-to-peer systems is to construct an overlay network that
resembles a random graph. The basic model is that each node maintains a list of
c neighbors, where, ideally, each of these neighbors represents a randomly
chosen live node from the current set of nodes. The list of neighbors is also
referred to as a partial view. There are many ways to construct such a partial
view. Jelasity et al. (2004, 2005a) have developed a framework that captures many
different algorithms for overlay construction to allow for evaluations and
comparison. In this framework, it is assumed that nodes regularly exchange
entries from their partial view. Each entry identifies another node in the
network, and has an associated age that indicates how old the reference to that
node is. Two threads are used, as shown in Fig. 2-9.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>The active thread takes the
initiative to communicate with another node. It selects that node from its
current partial view. Assuming that entries need to be pushed to the selected
peer, it continues by constructing a buffer containing c/2+1 entries, including
an entry identifying itself. The other entries are taken from the current
partial view.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>If the node is also in pull
mode it will wait for a response from the selected peer. That peer, in the
meantime, will also have constructed a buffer by means the passive thread shown
in Fig. 2-9(b), whose activities strongly resemble that of the active thread.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>The crucial point is the construction
of a new partial view. This view, for initiating as well as for the contacted
peer, will contain exactly c entries, part of which will come from received
buffer. In essence, there are two ways to construct the new view. First, the
two nodes may decide to discard the entries that they had sent to each other.
Effectively, this means that they will swap part of their original views. The
second approach is to discard as many old entries as possible. In general, it
turns out that the two approaches are complementary [see Jelasity et al.
(2005a) for the details]. It turns out that many membership management
protocols for unstructured overlays fit this framework. There are a number of
interesting observations to make.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>First, let us assume that
when a node wants to join it contacts an arbitrary other node, possibly from a
list of well-known access points. This access point is just a regular member of
the overlay, except that we can assume it to be highly available. In this case,
it turns out that protocols that use only push mode or only pull mode can
fairly easily lead to disconnected overlays. In other words, groups of nodes
will become isolated and will never be able to reach every other node in the
network. Clearly, this is an undesirable feature, for which reason it makes
more sense to let nodes actually exchange entries.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>[Page 48]<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Figure 2-9. (a) The steps
taken by the active thread. (b) The steps take by the passive thread.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<table border=1 cellspacing=0 cellpadding=0 bgcolor=white style='background:
 white;border-collapse:collapse;border:none;mso-border-alt:solid windowtext .5pt;
 mso-padding-alt:0in 5.4pt 0in 5.4pt'>
 <tr style='height:476.5pt'>
  <td width=799 valign=top style='width:599.6pt;border:solid windowtext .5pt;
  padding:0in 5.4pt 0in 5.4pt;height:476.5pt'>
  <p class=MsoNormal><b><span style='font-family:Arial'>Actions by active
  thread (periodically repeated):<o:p></o:p></span></b></p>
  <p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>
  <p class=MsoNormal><span style='font-family:"Courier New"'><span
  style="mso-spacerun: yes">    </span>select a peer P from the current partial
  view;<o:p></o:p></span></p>
  <p class=MsoNormal><span style='font-family:"Courier New"'><span
  style="mso-spacerun: yes">    </span>if PUSH_MODE {<o:p></o:p></span></p>
  <p class=MsoNormal><span style='font-family:"Courier New"'><span
  style="mso-spacerun: yes">       </span>mybuffer = [(MyAddress, 0)];<o:p></o:p></span></p>
  <p class=MsoNormal><span style='font-family:"Courier New"'><span
  style="mso-spacerun: yes">       </span>permute partial view;<o:p></o:p></span></p>
  <p class=MsoNormal><span style='font-family:"Courier New"'><span
  style="mso-spacerun: yes">       </span>move H oldest entries to the end;<o:p></o:p></span></p>
  <p class=MsoNormal><span style='font-family:"Courier New"'><span
  style="mso-spacerun: yes">       </span>append first c/2 entries to mybuffer;<o:p></o:p></span></p>
  <p class=MsoNormal><span style='font-family:"Courier New"'><span
  style="mso-spacerun: yes">       </span>send mybuffer to P;<o:p></o:p></span></p>
  <p class=MsoNormal><span style='font-family:"Courier New"'><span
  style="mso-spacerun: yes">    </span>} else {<o:p></o:p></span></p>
  <p class=MsoNormal><span style='font-family:"Courier New"'><span
  style="mso-spacerun: yes">       </span>send trigger to P;<o:p></o:p></span></p>
  <p class=MsoNormal><span style='font-family:"Courier New"'><span
  style="mso-spacerun: yes">    </span>}<o:p></o:p></span></p>
  <p class=MsoNormal><span style='font-family:"Courier New"'><span
  style="mso-spacerun: yes">    </span>if PULL_MODE {<o:p></o:p></span></p>
  <p class=MsoNormal><span style='font-family:"Courier New"'><span
  style="mso-spacerun: yes">       </span>receive P's buffer;<o:p></o:p></span></p>
  <p class=MsoNormal><span style='font-family:"Courier New"'><span
  style="mso-spacerun: yes">    </span>}<o:p></o:p></span></p>
  <p class=MsoNormal><span style='font-family:"Courier New"'><span
  style="mso-spacerun: yes">    </span>construct a new partial view from the
  current one and P's buffer;<o:p></o:p></span></p>
  <p class=MsoNormal><span style='font-family:"Courier New"'><span
  style="mso-spacerun: yes">    </span>increment the age of every entry in the
  new partial view;<o:p></o:p></span></p>
  <p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>
  <p class=MsoNormal><b><span style='font-family:Arial'><span
  style="mso-spacerun: yes">                                         </span>(a)<o:p></o:p></span></b></p>
  <p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>
  <p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>
  <p class=MsoNormal><b><span style='font-family:Arial'>Actions by passive
  thread:<o:p></o:p></span></b></p>
  <p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>
  <p class=MsoNormal><span style='font-family:"Courier New"'><span
  style="mso-spacerun: yes">    </span>receive buffer from any process Q;<o:p></o:p></span></p>
  <p class=MsoNormal><span style='font-family:"Courier New"'><span
  style="mso-spacerun: yes">    </span>if PULL_MODE {<o:p></o:p></span></p>
  <p class=MsoNormal><span style='font-family:"Courier New"'><span
  style="mso-spacerun: yes">       </span>mybuffer = [(MyAddress, 0)];<o:p></o:p></span></p>
  <p class=MsoNormal><span style='font-family:"Courier New"'><span
  style="mso-spacerun: yes">       </span>permute partial vie w;<o:p></o:p></span></p>
  <p class=MsoNormal><span style='font-family:"Courier New"'><span
  style="mso-spacerun: yes">       </span>move H oldest entries to the end;<o:p></o:p></span></p>
  <p class=MsoNormal><span style='font-family:"Courier New"'><span
  style="mso-spacerun: yes">       </span>append first c/2 entries to mybuffer;<o:p></o:p></span></p>
  <p class=MsoNormal><span style='font-family:"Courier New"'><span
  style="mso-spacerun: yes">       </span>send mybuffer to P;<o:p></o:p></span></p>
  <p class=MsoNormal><span style='font-family:"Courier New"'><span
  style="mso-spacerun: yes">    </span>}<o:p></o:p></span></p>
  <p class=MsoNormal><span style='font-family:"Courier New"'><span
  style="mso-spacerun: yes">    </span>construct a new partial view from the
  current one and P's buffer;<o:p></o:p></span></p>
  <p class=MsoNormal><span style='font-family:"Courier New"'><span
  style="mso-spacerun: yes">    </span>increment the age of every entry in the
  new partial view;<o:p></o:p></span></p>
  <p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>
  <p class=MsoNormal><b><span style='font-family:Arial'><span
  style="mso-spacerun: yes">                                         </span>(b)<o:p></o:p></span></b></p>
  </td>
 </tr>
</table>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Second, leaving the network turns
out to be a very simple operation provided the nodes exchange partial views on
a regular basis. In this case, a node can simply depart without informing any
other node. What will happen is that when a node P selects one of its apparent
neighbors, say node Q, and discovers that Q no longer responds, it simply
removes the entry from its partial view to select another peer. It turns out
that when constructing a new partial view, a node follows the policy to discard
as many old entries as possible, departed nodes will rapidly be forgotten. In
other words, entries referring to departed nodes will automatically be quickly
removed from partial views.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>[Page 49]<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>However, there is a price to
pay when this strategy is followed. To explain, consider for a node P the set
of nodes that have an entry in their partial view that refers to P.
Technically, this is known as the indegree of a node. The higher node P's
indegree is, the higher the probability that some other node will decide to
contact P. In other words, there is a danger that P will become a popular node,
which could easily bring it into an imbalanced position regarding workload.
Systematically discarding old entries turns out to promote nodes to ones having
a high indegree. There are other trade-offs in addition, for which we refer to
Jelasity et al. (2005a).<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Topology Management of
Overlay Networks<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Although it would seem that
structured and unstructured peer-to-peer systems form strict independent
classes, this need actually not be case [see also Castro et al. (2005)]. One
key observation is that by carefully exchanging and selecting entries from
partial views, it is possible to construct and maintain specific topologies of
overlay networks. This topology management is achieved by adopting a
two-layered approach, as shown in Fig. 2-10.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Figure 2-10. A two-layered
approach for constructing and maintaining specific overlay topologies using
techniques from unstructured peer-to-peer systems.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><!--[if gte vml 1]><v:shape
 id="_x0000_i1036" type="#_x0000_t75" style='width:512.25pt;height:231.75pt'>
 <v:imagedata src="./Chapter2_files/image023.jpg" o:title="fg2-10"/>
</v:shape><![endif]--><![if !vml]><img width=683 height=309
src="./Chapter2_files/image024.jpg" v:shapes="_x0000_i1036"><![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>The lowest layer constitutes
an unstructured peer-to-peer system in which nodes periodically exchange
entries of their partial views with the aim to maintain an accurate random
graph. Accuracy in this case refers to the fact that the partial view should be
filled with entries referring to randomly selected live nodes.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>The lowest layer passes its
partial view to the higher layer, where an additional selection of entries
takes place. This then leads to a second list of neighbors corresponding to the
desired topology. Jelasity and Babaoglu (2005) propose to use a ranking function
by which nodes are ordered according to some criterion relative to a given
node. A simple ranking function is to order a set of nodes by increasing
distance from a given node P. In that case, node P will gradually build up a
list of its nearest neighbors, provided the lowest layer continues to pass
randomly selected nodes.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>[Page 50]<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>As an illustration, consider
a logical grid of size NxN with a node placed on each point of the grid. Every
node is required to maintain a list of c nearest neighbors, where the distance
between a node at (a1, a2) and (b1, b2) is defined as d1+d2, with di=min (N-|
ai-bi|,|ai-bi|). If the lowest layer periodically executes the protocol as
outlined in Fig. 2-9, the topology that will evolve is a torus, shown in Fig.
2-11.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Figure 2-11. Generating a
specific overlay network using a two-layered unstructured peer-to-peer system
[adapted with permission from Jelasity and Babaoglu (2005)].<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><!--[if gte vml 1]><v:shape
 id="_x0000_i1037" type="#_x0000_t75" style='width:513pt;height:201pt'>
 <v:imagedata src="./Chapter2_files/image025.jpg" o:title="fg2-11"/>
</v:shape><![endif]--><![if !vml]><img width=684 height=268
src="./Chapter2_files/image026.jpg" v:shapes="_x0000_i1037"><![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Of course, completely
different ranking functions can be used. Notably those that are related to
capturing the semantic proximity of the data items as stored at a peer node are
interesting. This proximity allows for the construction of semantic overlay
networks that allow for highly efficient search algorithms in unstructured
peer-to-peer systems. We will return to these systems in Chap. 5 when we
discuss attribute-based naming.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Superpeers<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Notably in unstructured
peer-to-peer systems, locating relevant data items can become problematic as
the network grows. The reason for this scalability problem is simple: as there
is no deterministic way of routing a lookup request to a specific data item,
essentially the only technique a node can resort to is flooding the request.
There are various ways in which flooding can be dammed, as we will discuss in
Chap. 5, but as an alternative many peer-to-peer systems have proposed to make
use of special nodes that maintain an index of data items.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>There are other situations
in which abandoning the symmetric nature of peer-to-peer systems is sensible.
Consider a collaboration of nodes that offer resources to each other. For
example, in a collaborative content delivery network (CDN), nodes may offer
storage for hosting copies of Web pages allowing Web clients to access pages
nearby, and thus to access them quickly. In this case a node P may need to seek
for resources in a specific part of the network. In that case, making use of a
broker that collects resource usage for a number of nodes that are in each
other's proximity will allow to quickly select a node with sufficient
resources.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>[Page 51]<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Nodes such as those
maintaining an index or acting as a broker are generally referred to as
superpeers. As their name suggests, superpeers are often also organized in a
peer-to-peer network, leading to a hierarchical organization as explained in
Yang and Garcia-Molina (2003). A simple example of such an organization is
shown in Fig. 2-12. In this organization, every regular peer is connected as a
client to a superpeer. All communication from and to a regular peer proceeds through
that peer's associated superpeer.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Figure 2-12. A hierarchical
organization of nodes into a superpeer network.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><!--[if gte vml 1]><v:shape
 id="_x0000_i1038" type="#_x0000_t75" style='width:512.25pt;height:331.5pt'>
 <v:imagedata src="./Chapter2_files/image027.jpg" o:title="fg2-12"/>
</v:shape><![endif]--><![if !vml]><img width=683 height=442
src="./Chapter2_files/image028.jpg" v:shapes="_x0000_i1038"><![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>In many cases, the
client-superpeer relation is fixed: whenever a regular peer joins the network,
it attaches to one of the superpeers and remains attached until it leaves the
network. Obviously, it is expected that superpeers are long-lived processes
with a high availability. To compensate for potential unstable behavior of a
superpeer, backup schemes can be deployed, such as pairing every superpeer with
another one and requiring clients to attach to both.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Having a fixed association
with a superpeer may not always be the best solution. For example, in the case
of file-sharing networks, it may be better for a client to attach to a superpeer
that maintains an index of files that the client is generally interested in. In
that case, chances are bigger that when a client is looking for a specific
file, its superpeer will know where to find it. Garbacki et al. (2005) describe
a relatively simple scheme in which the client-superpeer relation can change as
clients discover better superpeers to associate with. In particular, a
superpeer returning the result of a lookup operation is given preference over
other superpeers.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>As we have seen, peer-to-peer
networks offer a flexible means for nodes to join and leave the network.
However, with superpeer networks a new problem is introduced, namely how to
select the nodes that are eligible to become superpeer. This problem is closely
related to the leader-election problem, which we discuss in Chap. 6, when we
return to electing superpeers in a peer-to-peer network.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>[Page 52]<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<h3>2.2.3. Hybrid Architectures</h3>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>So far, we have focused on
client-server architectures and a number of peer-to-peer architectures. Many
distributed systems combine architectural features, as we already came across
in superpeer networks. In this section we take a look at some specific classes
of distributed systems in which client-server solutions are combined with
decentralized architectures.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Edge-Server Systems<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>An important class of
distributed systems that is organized according to a hybrid architecture is
formed by edge-server systems. These systems are deployed on the Internet where
servers are placed &quot;at the edge&quot; of the network. This edge is formed
by the boundary between enterprise networks and the actual Internet, for
example, as provided by an Internet Service Provider (ISP). Likewise, where end
users at home connect to the Internet through their ISP, the ISP can be
considered as residing at the edge of the Internet. This leads to a general
organization as shown in Fig. 2-13.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Figure 2-13. Viewing the
Internet as consisting of a collection of edge servers.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><!--[if gte vml 1]><v:shape
 id="_x0000_i1039" type="#_x0000_t75" style='width:513pt;height:193.5pt'>
 <v:imagedata src="./Chapter2_files/image029.jpg" o:title="fg2-13"/>
</v:shape><![endif]--><![if !vml]><img width=684 height=258
src="./Chapter2_files/image030.jpg" v:shapes="_x0000_i1039"><![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>End users, or clients in
general, connect to the Internet by means of an edge server. The edge server's
main purpose is to serve content, possibly after applying filtering and
transcoding functions. More interesting is the fact that a collection of edge
servers can be used to optimize content and application distribution. The basic
model is that for a specific organization, one edge server acts as an origin
server from which all content originates. That server can use other edge
servers for replicating Web pages and such (Leff et al., 2004; Nayate et al.,
2004; and Rabinovich and Spatscheck, 2002). We will return to edge-server
systems in Chap. 12 when we discuss Web-based solutions.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>[Page 53]<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<h3>Collaborative Distributed Systems</h3>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Hybrid structures are
notably deployed in collaborative distributed systems. The main issue in many
of these systems to first get started, for which often a traditional
client-server scheme is deployed. Once a node has joined the system, it can use
a fully decentralized scheme for collaboration.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>To make matters concrete,
let us first consider the BitTorrent file-sharing system (Cohen, 2003).
BitTorrent is a peer-to-peer file downloading system. Its principal working is
shown in Fig. 2-14 The basic idea is that when an end user is looking for a
file, he downloads chunks of the file from other users until the downloaded
chunks can be assembled together yielding the complete file. An important
design goal was to ensure collaboration. In most file-sharing systems, a
significant fraction of participants merely download files but otherwise
contribute close to nothing (Adar and Huberman, 2000; Saroiu et al., 2003; and
Yang et al., 2005). To this end, a file can be downloaded only when the
downloading client is providing content to someone else. We will return to this
&quot;tit-for-tat&quot; behavior shortly.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Figure 2-14. The principal
working of BitTorrent [adapted with permission from Pouwelse et al. (2004)].<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><!--[if gte vml 1]><v:shape
 id="_x0000_i1040" type="#_x0000_t75" style='width:512.25pt;height:151.5pt'>
 <v:imagedata src="./Chapter2_files/image031.jpg" o:title="fg2-14"/>
</v:shape><![endif]--><![if !vml]><img width=683 height=202
src="./Chapter2_files/image032.jpg" v:shapes="_x0000_i1040"><![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>To download a file, a user
needs to access a global directory, which is just one of a few well-known Web sites.
Such a directory contains references to what are called .torrent files. A
.torrent file contains the information that is needed to download a specific
file. In particular, it refers to what is known as a tracker, which is a server
that is keeping an accurate account of active nodes that have (chunks) of the
requested file. An active node is one that is currently downloading another
file. Obviously, there will be many different trackers, although there will
generally be only a single tracker per file (or collection of files).<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Once the nodes have been
identified from where chunks can be downloaded, the downloading node
effectively becomes active. At that point, it will be forced to help others,
for example by providing chunks of the file it is downloading that others do
not yet have. This enforcement comes from a very simple rule: if node P notices
that node Q is downloading more than it is uploading, P can decide to decrease
the rate at which it sends data to Q. This scheme works well provided P has something
to download from Q. For this reason, nodes are often supplied with references
to many other nodes putting them in a better position to trade data.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>[Page 54]<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Clearly, BitTorrent combines
centralized with decentralized solutions. As it turns out, the bottleneck of
the system is, not surprisingly, formed by the trackers.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>As another example, consider
the Globule collaborative content distribution network (Pierre and van Steen,
2006). Globule strongly resembles the edge-server architecture mentioned above.
In this case, instead of edge servers, end users (but also organizations)
voluntarily provide enhanced Web servers that are capable of collaborating in
the replication of Web pages. In its simplest form, each such server has the
following components:<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal style='mso-list:l2 level1 lfo14;tab-stops:list .5in'><span
     style='font-family:Arial'>A component that can redirect client requests to
     other servers.<o:p></o:p></span></li>
</ol>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<ol style='margin-top:0in' start=2 type=1>
 <li class=MsoNormal style='mso-list:l2 level1 lfo14;tab-stops:list .5in'><span
     style='font-family:Arial'>A component for analyzing access patterns.<o:p></o:p></span></li>
</ol>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<ol style='margin-top:0in' start=3 type=1>
 <li class=MsoNormal style='mso-list:l2 level1 lfo14;tab-stops:list .5in'><span
     style='font-family:Arial'>A component for managing the replication of Web
     pages.<o:p></o:p></span></li>
</ol>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>The server provided by Alice
is the Web server that normally handles the traffic for Alice's Web site and is
called the origin server for that site. It collaborates with other servers, for
example, the one provided by Bob, to host the pages from Bob's site. In this
sense, Globule is a decentralized distributed system. Requests for Alice's Web
site are initially forwarded to her server, at which point they may be
redirected to one of the other servers. Distributed redirection is also
supported.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>However, Globule also has a
centralized component in the form of its broker. The broker is responsible for
registering servers, and making these servers known to others. Servers
communicate with the broker completely analogous to what one would expect in a
client-server system. For reasons of availability, the broker can be
replicated, but as we shall later in this book, this type of replication is
widely applied in order to achieve reliable client-server computing.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<h3>2.3. Architectures Versus Middleware</h3>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>When considering the
architectural issues we have discussed so far, a question that comes to mind is
where middleware fits in. As we discussed in Chap. 1, middleware forms a layer
between applications and distributed platforms, as shown in Fig. 1-1. An
important purpose is to provide a degree of distribution transparency, that is,
to a certain extent hiding the distribution of data, processing, and control
from applications.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>What is comonly seen in
practice is that middleware systems actually follow a specific architectural
sytle. For example, many middleware solutions have adopted an object-based
architectural style, such as CORBA (OMG, 2004a). Others, like TIB/Rendezvous
(TIBCO, 2005) provide middleware that follows the event-based architectural
style. In later chapters, we will come across more examples of architectural
styles.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>[Page 55]<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Having middleware molded
according to a specific architectural style has the benefit that designing
applications may become simpler. However, an obvious drawback is that the
middleware may no longer be optimal for what an application developer had in
mind. For example, CORBA initially offered only objects that could be invoked
by remote clients. Later, it was felt that having only this form of interaction
was too restrictive, so that other interaction patterns such as messaging were
added. Obviously, adding new features can easily lead to bloated middle-ware
solutions.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>In addition, although
middleware is meant to provide distribution transparency, it is generally felt
that specific solutions should be adaptable to application requirements. One
solution to this problem is to make several versions of a middleware system,
where each version is tailored to a specific class of applications. An approach
that is generally considered better is to make middleware systems such that
they are easy to configure, adapt, and customize as needed by an application.
As a result, systems are now being developed in which a stricter separation
between policies and mechanisms is being made. This has led to several
mechanisms by which the behavior of middleware can be modified (Sadjadi and
McKinley, 2003). Let us take a look at some of the commonly followed
approaches.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>2.3.1. Interceptors<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Conceptually, an interceptor
is nothing but a software construct that will break the usual flow of control
and allow other (application specific) code to be executed. To make
interceptors generic may require a substantial implementation effort, as
illustrated in Schmidt et al. (2000), and it is unclear whether in such cases
generality should be preferred over restricted applicability and simplicity.
Also, in many cases having only limited interception facilities will improve
management of the software and the distributed system as a whole.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>To make matters concrete,
consider interception as supported in many object-based distributed systems.
The basic idea is simple: an object A can call a method that belongs to an
object B, while the latter resides on a different machine than A. As we explain
in detail later in the book, such a remote-object invocation is carried as a
three-step approach:<o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-family:Arial'>1. <span
style='mso-tab-count:1'>        </span>Object A is offered a local interface
that is exactly the same as the interface offered by object B. A simply calls
the method available in that interface.<o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-family:Arial'>2. <span
style='mso-tab-count:1'>        </span>The call by A is transformed into a
generic object invocation, made possible through a general object-invocation
interface offered by the middleware at the machine where A resides.<o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-family:Arial'>3. <span
style='mso-tab-count:1'>        </span>Finally, the generic object invocation
is transformed into a message that is sent through the transport-level network
interface as offered by A's local operating system.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Figure 2-15. Using
interceptors to handle remote-object invocations.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><!--[if gte vml 1]><v:shape
 id="_x0000_i1041" type="#_x0000_t75" style='width:452.25pt;height:342.75pt'>
 <v:imagedata src="./Chapter2_files/image033.jpg" o:title="fg2-15"/>
</v:shape><![endif]--><![if !vml]><img width=603 height=457
src="./Chapter2_files/image033.jpg" v:shapes="_x0000_i1041"><![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>After the first step, the
call B.do_something(value) is transformed into a generic call such as invoke(B,
&amp;do_something, value) with a reference to B's method and the parameters
that go along with the call. Now imagine that object B is replicated. In that
case, each replica should actually be invoked. This is a clear point where
interception can help. What the request-level interceptor will do is simply
call invoke(B, &amp;do_something, value) for each of the replicas. The beauty
of this all is that the object A need not be aware of the replication of B, but
also the object middleware need not have special components that deal with this
replicated call. Only the request-level interceptor, which may be added to the
middleware needs to know about B's replication.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>In the end, a call to a
remote object will have to be sent over the network. In practice, this means that
the messaging interface as offered by the local operating system will need to
be invoked. At that level, a message-level interceptor may assist in
transferring the invocation to the target object. For example, imagine that the
parameter value actually corresponds to a huge array of data. In that case, it
may be wise to fragment the data into smaller parts to have it assembled again
at the destination. Such a fragmentation may improve performance or
reliability. Again, the middleware need not be aware of this fragmentation; the
lower-level interceptor will transparently handle the rest of the communication
with the local operating system.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>[Page 57]<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<h3>2.3.2. General Approaches to Adaptive Software</h3>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>What interceptors actually
offer is a means to adapt the middleware. The need for adaptation comes from
the fact that the environment in which distributed applications are executed
changes continuously. Changes include those resulting from mobility, a strong
variance in the quality-of-service of networks, failing hardware, and battery
drainage, amongst others. Rather than making applications responsible for
reacting to changes, this task is placed in the middleware.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>These strong influences from
the environment have brought many designers of middleware to consider the
construction of adaptive software. However, adaptive software has not been as
successful as anticipated. As many researchers and developers consider it to be
an important aspect of modern distributed systems, let us briefly pay some
attention to it. McKinley et al. (2004) distinguish three basic techniques to
come to software adaptation:<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal style='mso-list:l4 level1 lfo18;tab-stops:list .5in'><span
     style='font-family:Arial'>Separation of concerns<o:p></o:p></span></li>
</ol>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<ol style='margin-top:0in' start=2 type=1>
 <li class=MsoNormal style='mso-list:l4 level1 lfo18;tab-stops:list .5in'><span
     style='font-family:Arial'>Computational reflection<o:p></o:p></span></li>
</ol>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<ol style='margin-top:0in' start=3 type=1>
 <li class=MsoNormal style='mso-list:l4 level1 lfo18;tab-stops:list .5in'><span
     style='font-family:Arial'>Component-based design<o:p></o:p></span></li>
</ol>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Separating concerns relates
to the traditional way of modularizing systems: separate the parts that
implement functionality from those that take care of other things (known as
extra functionalities) such as reliability, performance, security, etc. One can
argue that developing middleware for distributed applications is largely about
handling extra functionalities independent from applications. The main problem
is that we cannot easily separate these extra functionalities by means of
modularization. For example, simply putting security into a separate module is
not going to work. Likewise, it is hard to imagine how fault tolerance can be
isolated into a separate box and sold as an independent service. Separating and
subsequently weaving these cross-cutting concerns into a (distributed) system
is the major theme addressed by aspect-oriented software development (Filman et
al., 2005). However, aspect orientation has not yet been successfully applied
to developing large-scale distributed systems, and it can be expected that
there is still a long way to go before it reaches that stage.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Computational reflection
refers to the ability of a program to inspect itself and, if necessary, adapt
its behavior (Kon et al., 2002). Reflection has been built into programming
languages, including Java, and offers a powerful facility for runtime
modifications. In addition, some middleware systems provide the means to apply
reflective techniques. However, just as in the case of aspect orientation,
reflective middleware has yet to prove itself as a powerful tool to manage the
complexity of large-scale distributed systems. As mentioned by Blair et al.
(2004), applying reflection to a broad domain of applications is yet to be
done.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>[Page 58]<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Finally, component-based
design supports adaptation through composition. A system may either be
configured statically at design time, or dynamically at runtime. The latter
requires support for late binding, a technique that has been successfully
applied in programming language environments, but also for operating systems
where modules can be loaded and unloaded at will. Research is now well underway
to allow automatically selection of the best implementation of a component
during runtime (Yellin, 2003), but again, the process remains complex for
distributed systems, especially when considering that replacement of one
component requires knowning what the effect of that replacement on other
components will be. In many cases, components are less independent as one may
think.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><b><span style='font-family:Arial'>2.3.3. Discussion<o:p></o:p></span></b></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Software architectures for
distributed systems, notably found as middleware, are bulky and complex. In
large part, this bulkiness and complexity arises from the need to be general in
the sense that distribution transparency needs to be provided. At the same time
applications have specific extra-functional requirements that conflict with
aiming at fully achieving this transparency. These conflicting requirements for
generality and specialization have resulted in middleware solutions that are
highly flexible. The price to pay, however, is complexity. For example, Zhang
and Jacobsen (2004) report a 50% increase in the size of a particular software
product in just four years since its introduction, whereas the total number of
files for that product had tripled during the same period. Obviously, this is
not an encouraging direction to pursue.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Considering that virtually
all large software systems are nowadays required to execute in a networked
environment, we can ask ourselves whether the complexity of distributed systems
is simply an inherent feature of attempting to make distribution transparent.
Of course, issues such as openness are equally important, but the need for
flexibility has never been so prevalent as in the case of middleware.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Coyler et al. (2003) argue
that what is needed is a stronger focus on (external) simplicity, a simpler way
to construct middleware by components, and application independence. Whether
any of the techniques mentioned above forms the solution is subject to debate.
In particular, none of the proposed techniques so far have found massive
adoption, nor have they been successfully applied to large-scale systems.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>The underlying assumption is
that we need adaptive software in the sense that the software should be allowed
to change as the environment changes. However, one should question whether adapting
to a changing environment is a good reason to adopt changing the software.
Faulty hardware, security attacks, energy drainage, and so on, all seem to be
environmental influences that can (and should) be anticipated by software.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>[Page 59]<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>The strongest, and certainly
most valid, argument for supporting adaptive software is that many distributed
systems cannot be shut down. This constraint calls for solutions to replace and
upgrade components on the fly, but is not clear whether any of the solutions
proposed above are the best ones to tackle this maintenance problem.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>What then remains is that
distributed systems should be able to react to changes in their environment by,
for example, switching policies for allocating resources. All the software components
to enable such an adaptation will already be in place. It is the algorithms
contained in these components and which dictate the behavior that change their
settings. The challenge is to let such reactive behavior take place without
human intervention. This approach is seen to work better when discussing the
physical organization of distributed systems when decisions are taken about
where components are placed, for example. We discuss such system architectural
issues next.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><b><span style='font-family:Arial'>2.4. Self-Management in
Distributed Systems<o:p></o:p></span></b></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Distributed systems—and
notably their associated middleware—need to provide general solutions toward
shielding undesirable features inherent to networking so that they can support
as many applications as possible. On the other hand, full distribution
transparency is not what most applications actually want, resulting in
application-specific solutions that need to be supported as well. We have
argued that, for this reason, distributed systems should be adaptive, but
notably when it comes to adapting their execution behavior and not the software
components they comprise.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>When adaptation needs to be
done automatically, we see a strong interplay between system architectures and
software architectures. On the one hand, we need to organize the components of
a distributed system such that monitoring and adjustments can be done, while on
the other hand we need to decide where the processes are to be executed that
handle the adaptation.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>In this section we pay
explicit attention to organizing distributed systems as high-level
feedback-control systems allowing automatic adaptations to changes. This
phenomenon is also known as autonomic computing (Kephart, 2003) or self-star
systems (Babaoglu et al., 2005). The latter name indicates the variety by which
automatic adaptations are being captured: self-managing, self-healing,
self-configuring, self-optimizing, and so on. We resort simply to using the
name self-managing systems as coverage of its many variants.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>[Page 60]<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<h3>2.4.1. The Feedback Control Model</h3>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>There are many different
views on self-managing systems, but what most have in common (either explicitly
or implicitly) is the assumption that adaptations take place by means of one or
more feedback control loops. Accordingly, systems that are organized by means
of such loops are referred to as feedback control systems. Feedback control has
since long been applied in various engineering fields, and its mathematical
foundations are gradually also finding their way in computing systems
(Hellerstein et al., 2004; and Diao et al., 2005). For self-managing systems,
the architectural issues are initially the most interesting. The basic idea
behind this organization is quite simple, as shown in Fig. 2-16.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Figure 2-16. The logical
organization of a feedback control system.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><!--[if gte vml 1]><v:shape
 id="_x0000_i1042" type="#_x0000_t75" style='width:512.25pt;height:231.75pt'>
 <v:imagedata src="./Chapter2_files/image034.jpg" o:title="fg2-16"/>
</v:shape><![endif]--><![if !vml]><img width=683 height=309
src="./Chapter2_files/image035.jpg" v:shapes="_x0000_i1042"><![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>The core of a feedback
control system is formed by the components that need to be managed. These
components are assumed to be driven through controllable input parameters, but
their behavior may be influenced by all kinds of uncontrollable input, also
known as disturbance or noise input. Although disturbance will often come from
the environment in which a distributed system is executing, it may well be the
case that unanticipated component interaction causes unexpected behavior.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>There are essentially three
elements that form the feedback control loop. First, the system itself needs to
be monitored, which requires that various aspects of the system need to be
measured. In many cases, measuring behavior is easier said than done. For
example, round-trip delays in the Internet may vary wildly, and also depend on
what exactly is being measured. In such cases, accurately estimating a delay
may be difficult indeed. Matters are further complicated when a node A needs to
estimate the latency between two other completely different nodes B and C,
without being able to intrude on either two nodes. For reasons as this, a
feedback control loop generally contains a logical metric estimation component.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>[Page 61]<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Another part of the feedback
control loop analyzes the measurements and compares these to reference values.
This feedback analysis component forms the heart of the control loop, as it
will contain the algorithms that decide on possible adaptations.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>The last group of components
consist of various mechanisms to directly influence the behavior of the system.
There can be many different mechanisms: placing replicas, changing scheduling
priorities, switching services, moving data for reasons of availability,
redirecting requests to different servers, etc. The analysis component will
need to be aware of these mechanisms and their (expected) effect on system
behavior. Therefore, it will trigger one or several mechanisms, to subsequently
later observe the effect.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>An interesting observation
is that the feedback control loop also fits the manual management of systems.
The main difference is that the analysis component is replaced by human
administrators. However, in order to properly manage any distributed system,
these administrators will need decent monitoring equipment as well as decent
mechanisms to control the behavior of the system. It should be clear that
properly analyzing measured data and triggering the correct actions makes the
development of self-managing systems so difficult.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>It should be stressed that
Fig. 2-16 shows the logical organization of a self-managing system, and as such
corresponds to what we have seen when discussing software architectures.
However, the physical organization may be very different. For example, the
analysis component may be fully distributed across the system. Likewise, taking
performance measurements are usually done at each machine that is part of the
distributed system. Let us now take a look at a few concrete examples on how to
monitor, analyze, and correct distributed systems in an automatic fashion.
These examples will also illustrate this distinction between logical and
physical organization.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>2.4.2. Example: Systems
Monitoring with Astrolabe<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>As our first example, we
consider Astrolabe (Van Renesse et al., 2003), which is a system that can
support general monitoring of very large distributed systems. In the context of
self-managing systems, Astrolabe is to be positioned as a general tool for
observing systems behavior. Its output can be used to feed into an analysis
component for deciding on corrective actions.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Astrolabe organizes a large
collection of hosts into a hierarchy of zones. The lowest-level zones consist
of just a single host, which are subsequently grouped into zones of increasing
size. The top-level zone covers all hosts. Every host runs an Astrolabe
process, called an agent, that collects information on the zones in which that
host is contained. The agent also communicates with other agents with the aim
to spread zone information across the entire system.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Each host maintains a set of
attributes for collecting local information. For example, a host may keep track
of specific files it stores, its resource usage, and so on. Only the attributes
as maintained directly by hosts, that is, at the lowest level of the hierarchy
are writable. Each zone can also have a collection of attributes, but the
values of these attributes are computed from the values of lower level zones.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>[Page 62]<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Consider the following
simple example shown in Fig. 2-17 with three hosts, A, B, and C grouped into a
zone. Each machine keeps track of its IP address, CPU load, available free
memory, and the number of active processes. Each of these attributes can be
directly written using local information from each host. At the zone level,
only aggregated information can be collected, such as the average CPU load, or
the average number of active processes.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Figure 2-17. Data collection
and information aggregation in Astrolabe.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><!--[if gte vml 1]><v:shape
 id="_x0000_i1043" type="#_x0000_t75" style='width:512.25pt;height:297pt'>
 <v:imagedata src="./Chapter2_files/image036.jpg" o:title="fg2-17"/>
</v:shape><![endif]--><![if !vml]><img width=683 height=396
src="./Chapter2_files/image037.jpg" v:shapes="_x0000_i1043"><![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Fig. 2-17 shows how the
information as gathered by each machine can be viewed as a record in a
database, and that these records jointly form a relation (table). This
representation is done on purpose: it is the way that Astrolabe views all the
collected data. However, per zone information can only be computed from the
basic records as maintained by hosts.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Aggregated information is
obtained by programmable aggregation functions, which are very similar to
functions available in the relational database language SQL. For example,
assuming that the host information from Fig. 2-17 is maintained in a local
table called hostinfo, we could collect the average number of processes for the
zone containing machines A, B, and C, through the simple SQL query<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>SELECT AVG(procs) AS
avg_procs FROM hostinfo<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Combined with a few
enhancements to SQL, it is not hard to imagine that more informative queries
can be formulated.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Queries such as these are
continuously evaluated by each agent running on each host. Obviously, this is
possible only if zone information is propagated to all nodes that comprise
Astrolabe. To this end, an agent running on a host is responsible for computing
parts of the tables of its associated zones. Records for which it holds no
computational responsibility are occasionally sent to it through a simple, yet
effective exchange procedure known as gossiping. Gossiping protocols will be
discussed in detail in Chap. 4. Likewise, an agent will pass computed results
to other agents as well.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>[Page 63]<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>The result of this
information exchange is that eventually, all agents that needed to assist in
obtaining some aggregated information will see the same result (provided that
no changes occur in the meantime).<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<h3>2.4.3. Example: Differentiating Replication Strategies in Globule</h3>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Let us now take a look at Globule,
a collaborative content distribution network (Pierre and van Steen, 2006).
Globule relies on end-user servers being placed in the Internet, and that these
servers collaborate to optimize performance through replication of Web pages.
To this end, each origin server (i.e., the server responsible for handling
updates of a specific Web site), keeps track of access patterns on a per-page
basis. Access patterns are expressed as read and write operations for a page,
each operation being timestamped and logged by the origin server for that page.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>In its simplest form,
Globule assumes that the Internet can be viewed as an edge-server system as we
explained before. In particular, it assumes that requests can always be passed
through an appropriate edge server, as shown in Fig. 2-18. This simple model
allows an origin server to see what would have happened if it had placed a
replica on a specific edge server. On the one hand, placing a replica closer to
clients would improve client-perceived latency, but this will induce traffic
between the origin server and that edge server in order to keep a replica
consistent with the original page.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Figure 2-18. The edge-server
model assumed by Globule.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><!--[if gte vml 1]><v:shape
 id="_x0000_i1044" type="#_x0000_t75" style='width:512.25pt;height:220.5pt'>
 <v:imagedata src="./Chapter2_files/image038.jpg" o:title="fg2-18"/>
</v:shape><![endif]--><![if !vml]><img width=683 height=294
src="./Chapter2_files/image039.jpg" v:shapes="_x0000_i1044"><![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>When an origin server
receives a request for a page, it records the IP address from where the request
originated, and looks up the ISP or enterprise network associated with that
request using the WHOIS Internet service (Deutsch et al., 1995). The origin
server then looks for the nearest existing replica server that could act as
edge server for that client, and subsequently computes the latency to that
server along with the maximal bandwidth. In its simplest configuration, Globule
assumes that the latency between the replica server and the requesting user
machine is negligible, and likewise that bandwidth between the two is
plentiful.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>[Page 64]<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Once enough requests for a
page have been collected, the origin server performs a simple &quot;what-if
analysis.&quot; Such an analysis boils down to evaluating several replication
policies, where a policy describes where a specific page is replicated to, and
how that page is kept consistent. Each replication policy incurs a cost that
can be expressed as a simple linear function:<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>cost=(w1xm1)+(w2xm2)+ . . .+(wnxmn)<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>where mk denotes a
performance metric and wk is the weight indicating how important that metric
is. Typical performance metrics are the aggregated delays between a client and
a replica server when returning copies of Web pages, the total consumed bandwidth
between the origin server and a replica server for keeping a replica
consistent, and the number of stale copies that are (allowed to be) returned to
a client (Pierre et al., 2002).<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>For example, assume that the
typical delay between the time a client C issues a request and when that page
is returned from the best replica server is dC ms. Note that what the best
replica server is, is determined by a replication policy. Let m1 denote the
aggregated delay over a given time period, that is, m1=&#931; dC. If the origin
server wants to optimize client-perceived latency, it will choose a relatively
high value for w1. As a consequence, only those policies that actually minimize
m1 will show to have relatively low costs.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>In Globule, an origin server
regularly evaluates a few tens of replication polices using a trace-driven
simulation, for each Web page separately. From these simulations, a best policy
is selected and subsequently enforced. This may imply that new replicas are installed
at different edge servers, or that a different way of keeping replicas
consistent is chosen. The collecting of traces, the evaluation of replication
policies, and the enforcement of a selected policy is all done automatically.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>There are a number of subtle
issues that need to be dealt with. For one thing, it is unclear how many
requests need to be collected before an evaluation of the current policy can
take place. To explain, suppose that at time Ti the origin server selects
policy p for the next period until Ti+1. This selection takes place based on a
series of past requests that were issued between Ti-1 and Ti. Of course, in
hindsight at time Ti+1, the server may come to the conclusion that it should
have selected policy p* given the actual requests that were issued between Ti
and Ti+1. If p* is different from p, then the selection of p at Ti was wrong.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>As it turns out, the
percentage of wrong predictions is dependent on the length of the series of
requests (called the trace length) that are used to predict and select a next
policy. This dependency is sketched in Fig. 2-19. What is seen is that the
error in predicting the best policy goes up if the trace is not long enough.
This is easily explained by the fact that we need enough requests to do a proper
evaluation. However, the error also increases if we use too many requests. The
reason for this is that a very long trace length captures so many changes in
access patterns that predicting the best policy to follow becomes difficult, if
not impossible. This phenomenon is well known and is analogous to trying to
predict the weather for tomorrow by looking at what happened during the
immediately preceding 100 years. A much better prediction can be made by just
looking only at the recent past.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>[Page 65]<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Figure 2-19. The dependency
between prediction accuracy and trace length.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><!--[if gte vml 1]><v:shape
 id="_x0000_i1045" type="#_x0000_t75" style='width:513pt;height:223.5pt'>
 <v:imagedata src="./Chapter2_files/image040.jpg" o:title="fg2-19"/>
</v:shape><![endif]--><![if !vml]><img width=684 height=298
src="./Chapter2_files/image041.jpg" v:shapes="_x0000_i1045"><![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Finding the optimal trace
length can be done automatically as well. We leave it as an exercise to sketch
a solution to this problem.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<h3>2.4.4. Example: Automatic Component Repair Management in Jade</h3>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>When maintaining clusters of
computers, each running sophisticated servers, it becomes important to
alleviate management problems. One approach that can be applied to servers that
are built using a component-based approach, is to detect component failures and
have them automatically replaced. The Jade system follows this approach
(Bouchenak et al., 2005). We describe it briefly in this section.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Jade is built on the Fractal
component model, a Java implementation of a framework that allows components to
be added and removed at runtime (Bruneton et al., 2004). A component in Fractal
can have two types of interfaces. A server interface is used to call methods
that are implemented by that component. A client interface is used by a component
to call other components. Components are connected to each other by binding
interfaces. For example, a client interface of component C1 can be bound to the
server interface of component C2. A primitive binding means that a call to a
client interface directly leads to calling the bounded server interface. In the
case of composite binding, the call may proceed through one or more other
components, for example, because the client and server interface did not match
and some kind of conversion is needed. Another reason may be that the connected
components lie on different machines.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>[Page 66]<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Jade uses the notion of a
repair management domain. Such a domain consists of a number of nodes, where
each node represents a server along with the components that are executed by
that server. There is a separate node manager which is responsible for adding
and removing nodes from the domain. The node manager may be replicated for
assuring high availability.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>Each node is equipped with
failure detectors, which monitor the health of a node or one of its components
and report any failures to the node manager. Typically, these detectors
consider exceptional changes in the state of component, the usage of resources,
and the actual failure of a component. Note that the latter may actually mean
that a machine has crashed.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>When a failure has been
detected, a repair procedure is started. Such a procedure is driven by a repair
policy, partly executed by the node manager. Policies are stated explicitly and
are carried out depending on the detected failure. For example, suppose a node
failure has been detected. In that case, the repair policy may prescribe that
the following steps are to be carried out:<o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-family:Arial'>1. <span
style='mso-tab-count:1'>        </span>Terminate every binding between a
component on a nonfaulty node, and a component on the node that just failed.<o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-family:Arial'>2. <span
style='mso-tab-count:1'>        </span>Request the node manager to start and
add a new node to the domain.<o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-family:Arial'>3. <span
style='mso-tab-count:1'>        </span>Configure the new node with exactly the
same components as those on the crashed node.<o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-family:Arial'>4. <span
style='mso-tab-count:1'>        </span>Re-establish all the bindings that were
previously terminated.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>In this example, the repair
policy is simple and will only work when no crucial data has been lost (the
crashed components are said to be stateless).<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:Arial'>The approach followed by
Jade is an example of self-management: upon the detection of a failure, a
repair policy is automatically executed to bring the system as a whole into a
state in which it was before the crash. Being a component-based system, this
automatic repair requires specific support to allow components to be added and
removed at runtime. In general, turning legacy applications into self-managing
systems is not possible.<o:p></o:p></span></p>

</div>

</body>

</html>
